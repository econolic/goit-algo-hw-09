# Касова система: Порівняння алгоритмів видачі решти

## Огляд

Проєкт реалізує дві функції для касової системи, що видає решту покупцеві:
- **Жадібний алгоритм** (`find_coins_greedy`)
- **Динамічне програмування** (`find_min_coins`)

## Алгоритми

### 1. Жадібний алгоритм

```python
def find_coins_greedy(amount: int, coins: Sequence[int] | None = None) -> CoinDict
```

**Принцип роботи:**
- Монети сортуються за спаданням (разово при підготовці у функції `_prepare_coins`)
- Завжди вибирає найбільший доступний номінал
- Віднімає `count = remaining // coin`; додає запис у словник
- Продовжує, доки залишок ≠ 0

**Складність:**
- Час: $O(k\cdot log k)$, де $k$ - кількість номіналів (через сортування у `_prepare_coins`). Для фіксованого набору стандартних монет, де підготовка може вважатися константною, основний цикл має складність $O(k)$
- Пам'ять: $O(k)$

### 2. Динамічне програмування

```python
def find_min_coins(amount: int, coins: Sequence[int] | None = None) -> CoinDict
```

**Принцип роботи:**
- Створює масив `dp[0…amount]`, де `dp[i]` – мінімальна кількість монет для суми *i*
- Ітерує всі монети `coin` і суми `i ≥ coin`, оновлюючи `dp`
- Відновлює шлях до оптимального набору монет через масив `prev_coin`

**Складність:**
- Час: $O(amount \cdot k)$, де $k$ - кількість номіналів
- Пам'ять: $O(amount)$

## Аналіз ефективності

### Часова складність

| Алгоритм | Складність | Для amount=1000 | Для amount=100000 |
|----------|------------|-----------------|-------------------|
| Жадібний | O(k logk) / O(k) | ~6 операцій | ~6 операцій |
| Динамічний | O(amount×k) | ~6000 операцій | ~600000 операцій |

Зазначені операції базуються на припущенні, що k - фіксована мала кількість монет (напр., 6 для стандартного набору), і для жадібного алгоритму враховується лише основний цикл.

### Бенчмарки

|Сума   | Жадібний (мс) |  DP (мс)  | К-ть (Greedy) | К-ть (DP) |
|-------|---------------|-----------|---------------|-----------|
|   113 |         0.002 |     0.030 |             5 |          5|
|   999 |         0.005 |     0.324 |            24 |         24|
|10000 |         0.001 |   3.387   |           200 |        200 |

*Параметри: Core i7-1255U, Python 3.12, 5 повторів.*

## Переваги та недоліки

### Жадібний алгоритм

**Переваги:**
- Дуже швидкий – $O(k \cdot log k)$ (або $O(k)$ для фіксованих наборів монет)
- Мінімальне використання пам'яті
- Простий у реалізації та розумінні
- Ідеальний для стандартних систем монет (євро, долар, гривня), де він зазвичай дає оптимальний результат

**Недоліки:**
- Не завжди знаходить оптимальне рішення для довільних наборів монет
- Для нестандартних систем номіналів може не знаходити оптимальне рішення або, у деяких випадках, не знаходити рішення взагалі (хоча наявність монети '1', перевірка якої є в коді, мінімізує останнє)
- Жадібна стратегія може бути помилковою для неканонічних наборів монет

### Динамічне програмування

**Переваги:**
- Завжди знаходить оптимальне рішення (мінімальну кількість монет)
- Гарантовано знаходить оптимальне рішення для будь-яких систем номіналів, якщо решту можливо видати
- Математично обґрунтований підхід

**Недоліки:**
- Повільний для великих сум - $O(amount \cdot k)$
- Високе споживання пам'яті - $O(amount)$
- Складніший у реалізації

## Рекомендації використання

### Коли використовувати жадібний алгоритм:
- Стандартні системи монет (гривня, євро, долар)
- Великі суми (>10000), де швидкість ДП стає неприйнятною
- Критично важлива швидкість виконання
- Обмежені ресурси пам'яті

### Коли використовувати динамічне програмування:
- Нестандартні системи номіналів, де жадібний алгоритм може не дати оптимального результату
- Потрібна абсолютна гарантія оптимальності рішення
- Малі та середні суми (наприклад, <10000), для яких час виконання ДП є прийнятним
- Достатньо часу та пам'яті для виконання

## Висновки

1. **Для стандартних касових систем** (українська гривня, євро, долар), де набори монет є канонічними, жадібний алгоритм є практично оптимальним вибором через свою надзвичайну швидкість та простоту.

2. **Жадібний алгоритм демонструє продуктивність**, що залежить переважно від кількості номіналів монет (k), а не від суми решти, що робить його ідеальним для високонавантажених систем зі стандартними монетами.

3. **Динамічне програмування доцільне переважно** для нестандартних систем номіналів або коли потрібна абсолютна гарантія оптимальності, а сума решти не є надто великою.

4. **Різниця у продуктивності збільшується лінійно** зі зростанням суми - для суми 100000 динамічний алгоритм може бути в 100000 разів повільнішим.

5. **Для реальних касових систем**, що використовують стандартні (канонічні) набори монет, жадібний алгоритм є рекомендованим через свою швидкість та простоту. Вбудовані в функції перевірки на можливість видачі решти (наприклад, генерація винятку `ChangeImpossibleError`) забезпечують надійність.

## Приклади використання

```python
from cash_system import find_coins_greedy, find_min_coins

print(find_coins_greedy(113))          # {50: 2, 10: 1, 2: 1, 1: 1}
print(find_min_coins(113))             # {50: 2, 10: 1, 2: 1, 1: 1}

# При неканонічних номіналах
coins = [1, 4, 5]
print(find_coins_greedy(8, coins))     # {5: 1, 1: 3} # 4 монети
print(find_min_coins(8, coins))        # {4: 2}       # 2 монети
```

### CLI

```bash
python cash_system.py 113 999  # жадібний vs DP для кількох сум
python cash_system.py -t       # всі unit-тести
```

## Тестування

* **Unit-тести**: `unittest` покриває канонічні й неканонічні системи, а також перевірку генерації винятків.